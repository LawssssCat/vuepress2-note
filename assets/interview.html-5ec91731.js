const l=JSON.parse('{"key":"v-ed99e76a","path":"/dev/java/java/interview.html","title":"Java 面试题目笔记","lang":"zh-CN","frontmatter":{"title":"Java 面试题目笔记","tags":["java","面试"]},"headers":[{"level":2,"title":"Java基础语法","slug":"java基础语法","link":"#java基础语法","children":[{"level":3,"title":"两个Integer比较","slug":"两个integer比较","link":"#两个integer比较","children":[]},{"level":3,"title":"String创建对象数","slug":"string创建对象数","link":"#string创建对象数","children":[]},{"level":3,"title":"finally 必须执行？","slug":"finally-必须执行","link":"#finally-必须执行","children":[]},{"level":3,"title":"volatile","slug":"volatile","link":"#volatile","children":[]},{"level":3,"title":"为什么JDK动态代理只能代理有接口的类","slug":"为什么jdk动态代理只能代理有接口的类","link":"#为什么jdk动态代理只能代理有接口的类","children":[]},{"level":3,"title":"StringBuffer和StringBuilder区别","slug":"stringbuffer和stringbuilder区别","link":"#stringbuffer和stringbuilder区别","children":[]},{"level":3,"title":"线上项目突发OOM ？如何快速定位OOM问题 ？","slug":"线上项目突发oom-如何快速定位oom问题","link":"#线上项目突发oom-如何快速定位oom问题","children":[{"level":4,"title":"出现OOM的可能原因","slug":"出现oom的可能原因","link":"#出现oom的可能原因","children":[]},{"level":4,"title":"定位OOM的问题","slug":"定位oom的问题","link":"#定位oom的问题","children":[]}]}]},{"level":2,"title":"JVM","slug":"jvm","link":"#jvm","children":[{"level":3,"title":"内存模型","slug":"内存模型","link":"#内存模型","children":[]},{"level":3,"title":"堆中对象结构","slug":"堆中对象结构","link":"#堆中对象结构","children":[{"level":4,"title":"Mark Word","slug":"mark-word","link":"#mark-word","children":[]}]},{"level":3,"title":"垃圾回收流程","slug":"垃圾回收流程","link":"#垃圾回收流程","children":[]},{"level":3,"title":"垃圾回收算法","slug":"垃圾回收算法","link":"#垃圾回收算法","children":[{"level":4,"title":"标记-清除算法","slug":"标记-清除算法","link":"#标记-清除算法","children":[]},{"level":4,"title":"复制算法","slug":"复制算法","link":"#复制算法","children":[]},{"level":4,"title":"标记整理算法","slug":"标记整理算法","link":"#标记整理算法","children":[]},{"level":4,"title":"分代搜集算法","slug":"分代搜集算法","link":"#分代搜集算法","children":[]}]},{"level":3,"title":"垃圾回收器","slug":"垃圾回收器","link":"#垃圾回收器","children":[{"level":4,"title":"Serial","slug":"serial","link":"#serial","children":[]},{"level":4,"title":"Parallel","slug":"parallel","link":"#parallel","children":[]},{"level":4,"title":"cms","slug":"cms","link":"#cms","children":[]},{"level":4,"title":"G1","slug":"g1","link":"#g1","children":[]}]},{"level":3,"title":"四种引用","slug":"四种引用","link":"#四种引用","children":[{"level":4,"title":"强引用","slug":"强引用","link":"#强引用","children":[]},{"level":4,"title":"软引用","slug":"软引用","link":"#软引用","children":[]},{"level":4,"title":"弱引用","slug":"弱引用","link":"#弱引用","children":[]},{"level":4,"title":"虚引用","slug":"虚引用","link":"#虚引用","children":[]}]},{"level":3,"title":"Unsafe类 todo","slug":"unsafe类-todo","link":"#unsafe类-todo","children":[]}]},{"level":2,"title":"调试工具","slug":"调试工具","link":"#调试工具","children":[{"level":3,"title":"jps","slug":"jps","link":"#jps","children":[]},{"level":3,"title":"jstat","slug":"jstat","link":"#jstat","children":[]},{"level":3,"title":"jstack","slug":"jstack","link":"#jstack","children":[]},{"level":3,"title":"jmap","slug":"jmap","link":"#jmap","children":[]},{"level":3,"title":"jconsole","slug":"jconsole","link":"#jconsole","children":[]},{"level":3,"title":"jvisualvm","slug":"jvisualvm","link":"#jvisualvm","children":[]},{"level":3,"title":"Arthas","slug":"arthas","link":"#arthas","children":[]}]},{"level":2,"title":"类加载器","slug":"类加载器","link":"#类加载器","children":[{"level":3,"title":"双亲委派","slug":"双亲委派","link":"#双亲委派","children":[]}]},{"level":2,"title":"异常","slug":"异常","link":"#异常","children":[]},{"level":2,"title":"线程","slug":"线程","link":"#线程","children":[{"level":3,"title":"生命周期","slug":"生命周期","link":"#生命周期","children":[]},{"level":3,"title":"线程实现方式","slug":"线程实现方式","link":"#线程实现方式","children":[]},{"level":3,"title":"线程池原理","slug":"线程池原理","link":"#线程池原理","children":[]},{"level":3,"title":"ThreadLocal","slug":"threadlocal","link":"#threadlocal","children":[{"level":4,"title":"ThreadLocal内存泄漏问题","slug":"threadlocal内存泄漏问题","link":"#threadlocal内存泄漏问题","children":[]}]},{"level":3,"title":"Executors创建线程缺点","slug":"executors创建线程缺点","link":"#executors创建线程缺点","children":[]},{"level":3,"title":"synchronized使用","slug":"synchronized使用","link":"#synchronized使用","children":[]},{"level":3,"title":"Synchronized升级","slug":"synchronized升级","link":"#synchronized升级","children":[]},{"level":3,"title":"Lock锁","slug":"lock锁","link":"#lock锁","children":[{"level":4,"title":"不公平锁和公平锁","slug":"不公平锁和公平锁","link":"#不公平锁和公平锁","children":[]}]},{"level":3,"title":"Synchronized和lock区别","slug":"synchronized和lock区别","link":"#synchronized和lock区别","children":[]},{"level":3,"title":"CAS机制","slug":"cas机制","link":"#cas机制","children":[]},{"level":3,"title":"AQS组件","slug":"aqs组件","link":"#aqs组件","children":[]}]},{"level":2,"title":"Web","slug":"web","link":"#web","children":[{"level":3,"title":"CSRF","slug":"csrf","link":"#csrf","children":[]},{"level":3,"title":"CORS","slug":"cors","link":"#cors","children":[{"level":4,"title":"解决跨域","slug":"解决跨域","link":"#解决跨域","children":[]}]}]},{"level":2,"title":"认证","slug":"认证","link":"#认证","children":[{"level":3,"title":"cookie","slug":"cookie","link":"#cookie","children":[]},{"level":3,"title":"jwt","slug":"jwt","link":"#jwt","children":[]},{"level":3,"title":"api key","slug":"api-key","link":"#api-key","children":[]}]},{"level":2,"title":"定时任务","slug":"定时任务","link":"#定时任务","children":[{"level":3,"title":"原理","slug":"原理","link":"#原理","children":[]},{"level":3,"title":"Quartz","slug":"quartz","link":"#quartz","children":[]},{"level":3,"title":"一个定时任务，执行周期很长，如何启停","slug":"一个定时任务-执行周期很长-如何启停","link":"#一个定时任务-执行周期很长-如何启停","children":[]}]},{"level":2,"title":"Java好习惯","slug":"java好习惯","link":"#java好习惯","children":[{"level":3,"title":"返回值改变时间","slug":"返回值改变时间","link":"#返回值改变时间","children":[]}]},{"level":2,"title":"Spring","slug":"spring","link":"#spring","children":[{"level":3,"title":"spring中的设计模式","slug":"spring中的设计模式","link":"#spring中的设计模式","children":[]},{"level":3,"title":"ioc di aop","slug":"ioc-di-aop","link":"#ioc-di-aop","children":[{"level":4,"title":"ioc加载过程","slug":"ioc加载过程","link":"#ioc加载过程","children":[]}]},{"level":3,"title":"SpringBean的生命周期","slug":"springbean的生命周期","link":"#springbean的生命周期","children":[]},{"level":3,"title":"循环依赖","slug":"循环依赖","link":"#循环依赖","children":[]},{"level":3,"title":"事务","slug":"事务","link":"#事务","children":[{"level":4,"title":"事务三个组件","slug":"事务三个组件","link":"#事务三个组件","children":[]},{"level":4,"title":"事务隔离性","slug":"事务隔离性","link":"#事务隔离性","children":[]},{"level":4,"title":"事务传播性","slug":"事务传播性","link":"#事务传播性","children":[]},{"level":4,"title":"回滚规则","slug":"回滚规则","link":"#回滚规则","children":[]},{"level":4,"title":"只读事务","slug":"只读事务","link":"#只读事务","children":[]},{"level":4,"title":"事务超时时间","slug":"事务超时时间","link":"#事务超时时间","children":[]},{"level":4,"title":"例子","slug":"例子","link":"#例子","children":[]}]}]},{"level":2,"title":"SpringMVC","slug":"springmvc","link":"#springmvc","children":[{"level":3,"title":"过滤器，拦截器","slug":"过滤器-拦截器","link":"#过滤器-拦截器","children":[]}]},{"level":2,"title":"MyBatis","slug":"mybatis","link":"#mybatis","children":[{"level":3,"title":"和jdbc的区别","slug":"和jdbc的区别","link":"#和jdbc的区别","children":[]},{"level":3,"title":"MyBatis的分页实现","slug":"mybatis的分页实现","link":"#mybatis的分页实现","children":[]},{"level":3,"title":"MyBatis的#{}和${}占位符区别","slug":"mybatis的-和-占位符区别","link":"#mybatis的-和-占位符区别","children":[]}]},{"level":2,"title":"数据库MySQL","slug":"数据库mysql","link":"#数据库mysql","children":[{"level":3,"title":"MySQL各种存储引擎对比","slug":"mysql各种存储引擎对比","link":"#mysql各种存储引擎对比","children":[]},{"level":3,"title":"MySQL表设计时间是用datetime还是timestamp","slug":"mysql表设计时间是用datetime还是timestamp","link":"#mysql表设计时间是用datetime还是timestamp","children":[]},{"level":3,"title":"事务四大特性 ACID","slug":"事务四大特性-acid","link":"#事务四大特性-acid","children":[]},{"level":3,"title":"事务隔离级别","slug":"事务隔离级别","link":"#事务隔离级别","children":[{"level":4,"title":"读未提交","slug":"读未提交","link":"#读未提交","children":[]},{"level":4,"title":"读已提交 RC","slug":"读已提交-rc","link":"#读已提交-rc","children":[]},{"level":4,"title":"可重复读 RR","slug":"可重复读-rr","link":"#可重复读-rr","children":[]},{"level":4,"title":"串行化","slug":"串行化","link":"#串行化","children":[]}]},{"level":3,"title":"MySQL事务原理","slug":"mysql事务原理","link":"#mysql事务原理","children":[]},{"level":3,"title":"MVCC 原理","slug":"mvcc-原理","link":"#mvcc-原理","children":[]},{"level":3,"title":"Update 行锁还是表锁","slug":"update-行锁还是表锁","link":"#update-行锁还是表锁","children":[]},{"level":3,"title":"共享锁/排他锁","slug":"共享锁-排他锁","link":"#共享锁-排他锁","children":[]},{"level":3,"title":"limit 500000, 10 优化","slug":"limit-500000-10-优化","link":"#limit-500000-10-优化","children":[]},{"level":3,"title":"索引失效","slug":"索引失效","link":"#索引失效","children":[]},{"level":3,"title":"为什么是B+树？","slug":"为什么是b-树","link":"#为什么是b-树","children":[]},{"level":3,"title":"索引优缺点","slug":"索引优缺点","link":"#索引优缺点","children":[]},{"level":3,"title":"聚簇和非聚簇索引","slug":"聚簇和非聚簇索引","link":"#聚簇和非聚簇索引","children":[]},{"level":3,"title":"索引下推？索引覆盖？回表？","slug":"索引下推-索引覆盖-回表","link":"#索引下推-索引覆盖-回表","children":[]},{"level":3,"title":"Redis和MySQL如何保证数据一致性","slug":"redis和mysql如何保证数据一致性","link":"#redis和mysql如何保证数据一致性","children":[]},{"level":3,"title":"分库分表","slug":"分库分表","link":"#分库分表","children":[{"level":4,"title":"垂直切分/水平切分","slug":"垂直切分-水平切分","link":"#垂直切分-水平切分","children":[]}]},{"level":3,"title":"常见分库分表中间件","slug":"常见分库分表中间件","link":"#常见分库分表中间件","children":[{"level":4,"title":"例子","slug":"例子-1","link":"#例子-1","children":[]}]},{"level":3,"title":"MySQL主从架构","slug":"mysql主从架构","link":"#mysql主从架构","children":[]}]},{"level":2,"title":"数据库Redis","slug":"数据库redis","link":"#数据库redis","children":[{"level":3,"title":"数据类型","slug":"数据类型","link":"#数据类型","children":[]},{"level":3,"title":"Redis缓存管理机制","slug":"redis缓存管理机制","link":"#redis缓存管理机制","children":[{"level":4,"title":"内存淘汰策略","slug":"内存淘汰策略","link":"#内存淘汰策略","children":[]},{"level":4,"title":"键的删除策略","slug":"键的删除策略","link":"#键的删除策略","children":[]}]},{"level":3,"title":"缓存灾难问题","slug":"缓存灾难问题","link":"#缓存灾难问题","children":[{"level":4,"title":"缓存击穿 2","slug":"缓存击穿-2","link":"#缓存击穿-2","children":[]},{"level":4,"title":"缓存雪崩 3","slug":"缓存雪崩-3","link":"#缓存雪崩-3","children":[]},{"level":4,"title":"缓存穿透 4","slug":"缓存穿透-4","link":"#缓存穿透-4","children":[]}]},{"level":3,"title":"Redis持久化","slug":"redis持久化","link":"#redis持久化","children":[{"level":4,"title":"持久化机制RDB","slug":"持久化机制rdb","link":"#持久化机制rdb","children":[]},{"level":4,"title":"持久化机制AOF","slug":"持久化机制aof","link":"#持久化机制aof","children":[]}]},{"level":3,"title":"哨兵和高可用","slug":"哨兵和高可用","link":"#哨兵和高可用","children":[{"level":4,"title":"主从","slug":"主从","link":"#主从","children":[]},{"level":4,"title":"哨兵机制（sentinel）","slug":"哨兵机制-sentinel","link":"#哨兵机制-sentinel","children":[]},{"level":4,"title":"高可用","slug":"高可用","link":"#高可用","children":[]},{"level":4,"title":"例子：redis集群","slug":"例子-redis集群","link":"#例子-redis集群","children":[]}]}]},{"level":2,"title":"消息队列RabbitMQ","slug":"消息队列rabbitmq","link":"#消息队列rabbitmq","children":[{"level":3,"title":"为什么用消息队列？","slug":"为什么用消息队列","link":"#为什么用消息队列","children":[]},{"level":3,"title":"消息队列选型","slug":"消息队列选型","link":"#消息队列选型","children":[]},{"level":3,"title":"RabbitMQ主从架构确保高可用","slug":"rabbitmq主从架构确保高可用","link":"#rabbitmq主从架构确保高可用","children":[]},{"level":3,"title":"Kafka分布式架构确保高可用","slug":"kafka分布式架构确保高可用","link":"#kafka分布式架构确保高可用","children":[]},{"level":3,"title":"生产者消费者模型 虚拟唤醒问题","slug":"生产者消费者模型-虚拟唤醒问题","link":"#生产者消费者模型-虚拟唤醒问题","children":[]},{"level":3,"title":"RabbitMQ架构设计","slug":"rabbitmq架构设计","link":"#rabbitmq架构设计","children":[]},{"level":3,"title":"RabbitMQ的事务消息处理","slug":"rabbitmq的事务消息处理","link":"#rabbitmq的事务消息处理","children":[]},{"level":3,"title":"RabbitMQ如何确保消息不丢失","slug":"rabbitmq如何确保消息不丢失","link":"#rabbitmq如何确保消息不丢失","children":[]},{"level":3,"title":"RabbitMQ如何确保消息不被重复消费","slug":"rabbitmq如何确保消息不被重复消费","link":"#rabbitmq如何确保消息不被重复消费","children":[]},{"level":3,"title":"RabbitMQ消息队列如何确保消息顺序性","slug":"rabbitmq消息队列如何确保消息顺序性","link":"#rabbitmq消息队列如何确保消息顺序性","children":[]},{"level":3,"title":"消息队列中消息堆积与过期处理方案","slug":"消息队列中消息堆积与过期处理方案","link":"#消息队列中消息堆积与过期处理方案","children":[]}]},{"level":2,"title":"分布式","slug":"分布式","link":"#分布式","children":[{"level":3,"title":"分布式锁","slug":"分布式锁","link":"#分布式锁","children":[{"level":4,"title":"分布式锁例子","slug":"分布式锁例子","link":"#分布式锁例子","children":[]}]},{"level":3,"title":"分布式事务","slug":"分布式事务","link":"#分布式事务","children":[]}]},{"level":2,"title":"网络","slug":"网络","link":"#网络","children":[{"level":3,"title":"三次握手","slug":"三次握手","link":"#三次握手","children":[]},{"level":3,"title":"四次挥手","slug":"四次挥手","link":"#四次挥手","children":[]},{"level":3,"title":"TCP 如何保证可靠传输","slug":"tcp-如何保证可靠传输","link":"#tcp-如何保证可靠传输","children":[]},{"level":3,"title":"服务网格","slug":"服务网格","link":"#服务网格","children":[]}]},{"level":2,"title":"加密","slug":"加密","link":"#加密","children":[]},{"level":2,"title":"算法","slug":"算法","link":"#算法","children":[{"level":3,"title":"哲学家就餐问题 —— 死锁","slug":"哲学家就餐问题-——-死锁","link":"#哲学家就餐问题-——-死锁","children":[{"level":4,"title":"模拟死锁过程","slug":"模拟死锁过程","link":"#模拟死锁过程","children":[]},{"level":4,"title":"解决死锁问题","slug":"解决死锁问题","link":"#解决死锁问题","children":[]}]},{"level":3,"title":"多任务同时失败 —— 分布式问题","slug":"多任务同时失败-——-分布式问题","link":"#多任务同时失败-——-分布式问题","children":[]}]}],"git":{"updatedTime":1703463370000,"contributors":[{"name":"lawsssscat","email":"18041500+LawssssCat@users.noreply.github.com","commits":4}]},"filePathRelative":"dev/java/java/interview.md"}');export{l as data};
